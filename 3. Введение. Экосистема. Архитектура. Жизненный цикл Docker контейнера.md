# Домашнее задание к занятию "3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

## Как сдавать задания

Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке.

Задачи со звездочкой (*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Любые вопросы по решению задач задавайте в чате учебной группы.

---


## Важно!

Перед отправкой работы на проверку удаляйте неиспользуемые ресурсы.
Это важно для того, чтоб предупредить неконтролируемый расход средств, полученных в результате использования промокода.

Подробные рекомендации [здесь](https://github.com/netology-code/virt-homeworks/blob/virt-11/r/README.md)

---

## Задача 1

Сценарий выполения задачи:

- создайте свой репозиторий на https://hub.docker.com;
- выберете любой образ, который содержит веб-сервер Nginx;
- создайте свой fork образа;
- реализуйте функциональность:
запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
```
Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.

### Ответ:

https://hub.docker.com/r/ivanskorobkov/123/tags

## Задача 2

Посмотрите на сценарий ниже и ответьте на вопрос:
"Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"

Детально опишите и обоснуйте свой выбор.

--

Сценарий:

- Высоконагруженное монолитное java веб-приложение;
- Nodejs веб-приложение;
- Мобильное приложение c версиями для Android и iOS;
- Шина данных на базе Apache Kafka;
- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
- Мониторинг-стек на базе Prometheus и Grafana;
- MongoDB, как основное хранилище данных для java-приложения;
- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.

### Ответ:

- Высоконагруженное монолитное java веб-приложение
В данном сценарии подходит Docker. Приложение будет поднято как микросервис + добавление большего количества копий с подсистемой балансировки нагрузки.
- Nodejs веб-приложение; 
В данном сценарии подходит Docker. Nodejs предполагает подход к разработке одного приложения как набора небольших сервисов (контейнеров), каждый из которых работает с собственными 
процессами и взаимодействует с легковесными механизмами, каждый микросервис (контейнер) обменивается данными с базой данных напрямую, такая архитектура позволяет повысить
производительность и скорость работы приложения.
- Мобильное приложение c версиями для Android и iOS;
В данном сценарии подходит Docker. Главное преимущество в этом случае является то, что в случае сборки приложения на другом устройстве нет необходимости в установке всего ПО, достаточно скачать необходимый образ.
- Шина данных на базе Apache Kafka;
В данном сценарии подходит Docker, но учитывая, что главным "потребителем" ресурсов здесь выступает Kafka, то я бы задействовал и физические машины. Kafka это распределенный горизонтально масштабируемый отказоустойчивый журнал коммитов, и тут главное горизонтально масштабируемый.
Поскольку мы будем иметь дело с данными, то неменуемо придем к их избыточности, в связи с этим связка Docker + Физ. машины обеспечат горизонтальное масштабирование на всех уровнях (физический виртуальны). 
Я предпологаю преминение технологии Docker исходя из его преимуществ: отказоустойчивость, масштабируемость и простота развертывания приложений (инфраструктуры).
- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
В данном сценарии подходит Docker, но если бы это ,sk стандартный стэк ELK. Я предполагаю, что в связи с тем что сам стэк являеться очень "прожорливым" в отношении ресурсов железа, то учитывая данный сценарий 
я бы поднимал данную архитектуру логирования на нескольких физических машинах, но с использованием техноолгии Docker.
- Мониторинг-стек на базе Prometheus и Grafana;
В данном сценарии подходит Docker. Сервер Prometheus является главным объектом и на Docker Hub есть готовые образы.Образ prom/prometheus без дополнительных опций запускает сервер Prometheus с конфигурационным файлом в  /etc/prometheus/prometheus.yml.
Для хранения данных этот образ использует смонтированный том данных Docker в каталоге /prometheus. Этот том данных является каталогом на хосте, который автоматически создаётся системой Docker при первом запуске контейнера.
При данной архитектуре мы получаем отказоустойчивую систему мониторинга (в случае сбоев контейнер падает, docker подымает новый, каталог данных монтирован на хосте). 
- MongoDB, как основное хранилище данных для java-приложения;
В данном сценарии подходит Docker. Опять же все упирается в обьем данных, т.к. MongoDB — это СУБД то единственным "слабым звеном" здесь является сама база данных, поэтому как и в предыдущих сценариях я бы оставлял место горизонтальному 
масштабированию на физическом уровне (т.е. сама СУБД контейнерная, а базы масштабируются физически).
- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.
В данном сценарии так же подойдет Docker. Поднимаем контейнер с Gitlab и контейнер с реестром. Настраиваем хранилище данных (привязываем каталог хоста например).

## Задача 3

- Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;
- Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;
- Добавьте еще один файл в папку ```/data``` на хостовой машине;
- Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

![Image alt](https://github.com/IvanSKorobkov/homework/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202023-01-28%2021-47-28.png)
![Image alt](https://github.com/IvanSKorobkov/homework/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202023-01-28%2021-48-29.png)
![Image alt](https://github.com/IvanSKorobkov/homework/blob/main/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202023-01-28%2021-48-32.png)

## Задача 4 (*)

Воспроизвести практическую часть лекции самостоятельно.

Соберите Docker образ с Ansible, загрузите на Docker Hub и пришлите ссылку вместе с остальными ответами к задачам.


---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
